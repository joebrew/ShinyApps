nAd <- length(unique(demVoters$adid[which(demVoters$Phone == myPhone)]))
# indicate whether it's not just 1
demVoters$badPhone[i] <- 1 != nAd
#   demVoters$badPhone[i] <-
#     1 != length(unique(demVoters$ad[which(demVoters$adid == demVoters$adid[i])])) #this used to have mistake
setTxtProgressBar(pb, i)
}
table(demVoters$badPhone)
barplot(table(demVoters$badPhone), main = "Bad phone number")
demVoters <- demVoters[which(!demVoters$badPhone),] # 48,260 dropped
save.image("temp3.RData")
demVoters$n <- NA
pb <- txtProgressBar(min=1,max=nrow(demVoters),style=3) ####### Progress of loop
for (i in 1:nrow(demVoters)){
demVoters$n[i] <-
nrow(demVoters[which(demVoters$adid == demVoters$adid[i]),])
setTxtProgressBar(pb, i)
}
table(factor(demVoters$n - 1))
table(factor(demVoters$n <=5))
prop.table(table(factor(demVoters$n - 1)))
barplot(table(factor(demVoters$n - 1)), main = "Cohabitation (how many roommates?)")
barplot(table(factor(demVoters$n <=5)), main = "Greater than 5 people in house?")
barplot(table(factor(demVoters$n >5)), main = "Greater than 5 people in house?")
par(mfrow=c(1,2))
barplot(table(factor(demVoters$n - 1)), main = "Cohabitation (how many roommates?)")
barplot(table(factor(demVoters$n >5)), main = "Greater than 5 people in house?")
par(mfrow=c(1,1))
demVoters <- demVoters[which(demVoters$n <=5),] #drops
save.image("temp3.RData")
demVoters2 <- demVoters
demVoters2 <- demVoters2[order(demVoters2$adid),]
head(demVoters2)
barplot(demVoters2$adid[1:200])
demVoters2$id <- cumsum(!duplicated(demVoters2$adid))
head(demVoters2)
barplot(demVoters2$id[1:200])
demVoters2$id <- cumsum(!duplicated(length(demVoters2$adid))
demVoters2$id <- cumsum(!duplicated(length(demVoters2$adid)))
demVoters2$id[1:100]
demVoters2$id[1:200]
rm(demVoters2)
set.seed(1)
# Write function for randomizing row order
RandomRows = function(df){
return(df[sample(nrow(df),nrow(df)),])
}
# Randomize row order
demVoters <- RandomRows(df = demVoters)
ad <- uniqueAds
df <- data.frame(ad)
library(plyr)
df <- join(x = df,
y = demVoters,
by = "ad",
type = "left",
match = "first")
# CREATE VARIABLE (phase1)
df$phase1 <- FALSE
dv2 <- demVoters
dv2$one <- 1
dv2$houseNum <- cumsum(!duplicated(dv2$one))
barplot(dv2$houseNum[1:100])
barplot(dv2$houseNum[1:300])
barplot(dv2$houseNum[1:1000])
rm(dv2)
# CREATE VARIABLE (phase1) (initially populate with all FALSES)
df$phase1 <- FALSE
phase1Sample <- sample(x = 1:nrow(df[which(df$Sex != "U"),]),
size = 60000,
replace = FALSE)
#2. assign indices
df$phase1[which(df$Sex != "U")][phase1Sample] <- TRUE
names(df)
summary(df$General12)
summary(VoteFun(df$General12))
summary(VoteFun("General12", data = df))
df$dum10 <- VoteFun("General10", data = df)
df$dfum12 <- VoteFun("General12", data = df)
fit <- glm(phase1 ~ Age + Sex + dum10 + dum12,
data = df,
family = binomial("logit"))
df$dum12 <- VoteFun("General12", data = df)
names(df)
df$dfum12 <- NULL
fit <- glm(phase1 ~ Age + Sex + dum10 + dum12,
data = df,
family = binomial("logit"))
summary(fit)
ci <- exp(cbind(OR = coef(fit), confint(fit)))
ci
summary(fit)
save.image("temp3.RData")
ci
barplot(ci[,1])
abline(h=1, col = "red")
df$Sex <- factor(df$Sex)
errbar(x=bp[,1]
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
library(Hmisc)
library(plyr)
length(unique(df$Phone))
length(unique(df$Phone[which(df$phase1)]))
length(unique(df$adid))
length(unique(df$adid[which(df$phase1)]))
bp
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
bp <- barplot(ci[-1,1], border = FALSE)
bp
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
bp <- barplot(ci[-1,1], border = FALSE, plot=FALSE, ylim=c(0,1.5))
bp
plot(bp)
barplot(bp)
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
bp <- barplot(ci[-1,1], border = FALSE, plot=TRUE, ylim=c(0,1.5))
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
ci <- exp(cbind(OR = coef(fit), confint(fit, level = 0.9)))
ci
bp <- barplot(ci[-1,1], border = FALSE, plot=TRUE, ylim=c(0,1.5))
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
bp <- barplot(ci[-1,1], border = FALSE, plot=TRUE, ylim=c(0,1.2))
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
# Run model
fit <- glm(phase1 ~ Age + Sex + dum10 + dum12,
data = df,
family = binomial("logit"))
summary(fit)
levels(df$Sex)
levels(factor(df$Sex))
df$Sex <- factor(df$Sex, levels = c("F", "M"))
levels(factor(df$Sex))
# First, create dummies as to whether or not they voted in 2010 and 2012
df$dum10 <- VoteFun("General10", data = df)
df$dum12 <- VoteFun("General12", data = df)
# for our model, we'll just use age, sex and voting in 2010 / 2012
# we don't have race, voter propensity
# and we choose not to use zip...
# Run model
fit <- glm(phase1 ~ Age + Sex + dum10 + dum12,
data = df,
family = binomial("logit"))
# View results
summary(fit)
# ! note: the having voted in 2012 general election dummy variable right on edge of p < 0.1 cutoff
# View confidence intervals on "odds" of assignment to phase 1
ci <- exp(cbind(OR = coef(fit), confint(fit, level = 0.9)))
ci
bp <- barplot(ci[-1,1], border = FALSE, plot=TRUE, ylim=c(0,1.2))
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
summary(demVoters$badPhone)
length(unique(demVoters$Phone))
length(df$adid)
length(df$Phone)
save.image("temp3.RData")
length(df$ad[which(df$phase1)])
length(df$Phone[which(df$phase1)])
phase1 <- df[which(df$phase1),c("VANID", "State", "Phone")]
write.csv(phase1, "preroboscreen/phase1.csv", row.names = FALSE)
library(TeachingDemos) # for easy sink()ing
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# THIS SCRIPT RANDOMIZES THE UH LOCAL 25 DATA, IN ACCORDANCE WITH WILL'S
# INSTRUCTIONS ON 2014-09-11.  IT IS AN IMPROVEMENT ON uh1.R AND uh2.R
set.seed(1)
library(RColorBrewer)
library(classInt)
library(TeachingDemos) # for easy sink()ing
library(Hmisc)
library(plyr)
#########
# SET LOCAL WORKING DIRECTORY
#########
setwd('C:/Users/BrewJR/Documents/analystinstitute/unitehere')
#########
# BEGIN WRITING SINK
#########
txtStart("uh3log.txt")
#########
# SET SEED
#########
set.seed(1)
#########
# ATTACH PACKAGES
#########
library(RColorBrewer)
library(classInt)
#########
# READ IN DATA, NAMING IT UH (unite here)
#########
uh <- read.csv("uh_with_party.txt", sep = "\t")
#########
# MAKE AN ADDRESS COLUMN
#########
# FUNCTION FOR REMOVING TRAILING / LEADING WHITE SPACES
RemoveTrail <- function(var){
x <- gsub("^\\s+|\\s+$", "", var)
return(x)
}
# CREATE AN ad COLUMN (first defining function, then assigning variable)
MakeAdd <- function(data = uh){
# PASTE TOGETHER ADDRESS COMPONENTS
x <- paste0(RemoveTrail(data$mAddress), ", ", #used mailing address, but should I use voting?
RemoveTrail(data$City), ", ",
RemoveTrail(data$State), " ",
RemoveTrail(data$Zip5))
return(x)
}
uh$ad <- MakeAdd(data = uh)
# CHECK LENGTH OF ADDRESSES (IN CHARACTERS) FOR ANY ODDITIES
table(factor(nchar(as.character(uh$ad))))
barplot(summary(factor(nchar(as.character(uh$ad)))))
# a bit concerned about some of those shorter addresses, so...
# REMOVE THOSE WITH FEWER THAN 31 CHARACTERS
# (any more and you start getting PO BOXES, ETC)
uh <- uh[which(nchar(as.character(uh$ad)) > 30),] #drops 895 bad addresses
# RECHECK LENGTH OF ADDRESSES (IN CHARACTERS) FOR ANY ODDITIES
table(factor(nchar(as.character(uh$ad))))
barplot(summary(factor(nchar(as.character(uh$ad)))))
# CHECK ON LONG ADDRESSES (JUST TO MAKE SURE NOTHING'S WONKY)
sample(uh$ad[which(nchar(as.character(uh$ad)) > 62)], 100) # they're fine
#########
# MAKE A VOTE HISTORY COLUMN PER SAUL'S SPECIFICATIONS
#########
# WRITE FUNCTION IN ORDER TO ESTABLISH WHETHER VOTED OR NOT IN A PARTICULAR COLUMN
VoteFun <- function(var, data = uh){
ifelse( nchar(as.character(data[,var])) > 0 & data[,var] != " ",
TRUE,
FALSE)
}
# BOOLEAN FOR WHETHER PERSON EVER VOTED IN 06, 10, OR 12
uh$voter <- ifelse(!VoteFun("General06") &
!VoteFun("General10") &
!VoteFun("General12") &
!VoteFun("Primary06") &
!VoteFun("Primary10") &
!VoteFun("Primary12") &
!VoteFun("Special12"),
FALSE,
TRUE)
# WHAT DOES VOTING HISTORY LOOK LIKE?
table(factor(uh$voter))
prop.table(table(factor(uh$voter)))
# 93.37% meet Saul's "voter" conditions
#########
# LIST OF VARIABLES FOR SAUL
#########
names(uh)
# 43 variables including the concocted "ad" (address) and "voter"
#########
# ONLY KEEP REGISTERED DEMS AND THOSE WITH NO PARTY
#########
table(grepl("D|N", uh$Party))
prop.table(table(grepl("D|N", uh$Party))) # 94.36% are dems or no party
#drop the other 5.6%
dems <- uh[which(grepl("D|N", uh$Party)),]
#########
# DROP ANYONE WHO DIDN'T VOTE IN 2006, 2010, OR 2012
#########
demVoters <- dems[which(dems$voter),] # this drops 14,637
rm(dems) # just to clean up workspace a bit
#########
# DROP THOSE WITH A MAILING ADDRESS OUTSIDE OF DC (WB, 2014-09-09 afternoon)
#########
# How many are there?
nrow(demVoters[which(demVoters$mState != "DC"),]) #3376
# Drop 'em
demVoters <- demVoters[which(demVoters$mState == "DC" ),]
#########
#Check for ID duplicates
#########
length(uh$VANID) != unique(length(uh$VANID)) #none
#########
#DROP PEOPLE WITH MISSING LAST NAMES, FIRST NAMES, MAIL ADDRESS, VOTER ADDRESS,
#AND PHONE
#########
# FIRST, DEFINE FUNCTION FOR MISSING
Missing <- function(var, df = demVoters){
nchar(as.character(df[,var])) == 0
}
# NOW DROP
demVoters <- demVoters[which(!Missing("LastName")),]
demVoters <- demVoters[which(!Missing("FirstName")),]
demVoters <- demVoters[which(!Missing("mAddress")),]
demVoters <- demVoters[which(!Missing("vAddress")),]
demVoters <- demVoters[which(!Missing("Zip5")),]
demVoters <- demVoters[which(!Missing("City")),]
demVoters <- demVoters[which(!Missing("State")),]
demVoters <- demVoters[which(!Missing("HomePhone")),]
demVoters <- demVoters[which(!Missing("Phone")),]
demVoters <- demVoters[which(!Missing("Age")),]
# The above didn't cause any drops
#######
# KEEP OBSERVATIONS WITH UNKNOWN SEX (DON'T RUN NEXT THREE LINES PER SAUL)
#######
# SEX - DROPPING UNKOWNS (this is what was done in the nh script)
#demVoters <- demVoters[which(demVoters$Sex != "U"),]
#demVoters$Sex <- factor(demVoters$Sex)
# But look at the strange gender distribution
table(factor(demVoters$Sex))
prop.table(table(factor(demVoters$Sex)))
barplot(table(factor(demVoters$Sex)), main = "Sex")
#########
# CREATE HOUSEHOLD ID
#########
uniqueAds <- unique(sort(demVoters$ad))
demVoters$adid <- NA
demVoters$adid <- match(demVoters$ad,uniqueAds)
#demVoters$adid <- as.numeric(as.factor(demVoters$ad)) #alternative
# Check to make sure that there there is only one adid for each add
length(unique(demVoters$adid)) == length(unique(demVoters$ad))
#########
# DROP ROWS FOR WHICH A PHONE NUMBER IS ASSOCIATED WITH MORE THAN ONE ADDRESS
#########
#create empty column for boolean bad phone or not
demVoters$badPhone <- NA
# establish progress bar for loop
pb <- txtProgressBar(min=1,max=nrow(demVoters),style=3) ####### Progress of loop
for (i in 1:nrow(demVoters)){
#isolate phone number
myPhone <- demVoters$Phone[i]
# number of addresses associated with that phone number
nAd <- length(unique(demVoters$adid[which(demVoters$Phone == myPhone)]))
# indicate whether it's anything besides 1
demVoters$badPhone[i] <- 1 != nAd
#update progress bar in loop
setTxtProgressBar(pb, i)
}
# How many of the 209,309 in our dataset have phones associated with more than one address?
table(demVoters$badPhone)
barplot(table(demVoters$badPhone), main = "Bad phone number")
#drop them
demVoters <- demVoters[which(!demVoters$badPhone),] # 48,260 dropped
#########
# # HOW MANY PEOPLE AT EACH ADDRESS ?
#########
demVoters$n <- NA
pb <- txtProgressBar(min=1,max=nrow(demVoters),style=3) ####### Progress of loop
for (i in 1:nrow(demVoters)){
demVoters$n[i] <-
nrow(demVoters[which(demVoters$adid == demVoters$adid[i]),])
setTxtProgressBar(pb, i)
}
# How many roommates do people have?
table(factor(demVoters$n - 1))
prop.table(table(factor(demVoters$n - 1)))
table(factor(demVoters$n <=5)) # 4094 have greater than 5 people in their house
par(mfrow=c(1,2))
barplot(table(factor(demVoters$n - 1)), main = "Cohabitation (how many roommates?)")
barplot(table(factor(demVoters$n >5)), main = "Greater than 5 people in house?")
par(mfrow=c(1,1))
#########
# EXCLUDE THOSE WITH HOUSEHOLD SIZE >=5 (doing this because in nh script it was done)
#########
demVoters <- demVoters[which(demVoters$n <=5),] #drops 4,094
#########
# HOUSEHOLD THE DATA BY RANDOMLY DRAWING A HOUSEHOLD REP IN HOUSEHOLDS
# WITH MORE THAN ONE INDIVIDUAL (OR BY DRAWING THE INDIVIDUAL WITH
# THE HIGHEST PHONE SCORE IN THE HOUSEHOLD, IF WE HAVE THAT INFO) - we don't!
# THE NEXT TWENTY LINES OR SO ARE FAST AND WORK WELL.  I WANTED TO FIND A MORE
# "READABLE" SOLUTION, BUT I ENDED UP STICKING WITH THIS ONE (OTHER OPTIONS SEEMED LESS UNDERSTANDABLE)
#########
#######
# RANDOMIZE ORDER OF ROWS
#######
set.seed(1)
# Write function for randomizing row order
RandomRows = function(df){
return(df[sample(nrow(df),nrow(df)),])
}
# Randomize row order
demVoters <- RandomRows(df = demVoters)
#########
# CREATE A DATAFRAME OF UNIQUE ADDRESSES TO HOUSEHOLD
#########
ad <- uniqueAds
df <- data.frame(ad)
#########
# LEFT JOIN demVoters INTO df (CREATES HOUSEHOLD-REPPED DATASET BY MATCHING FIRST OCCURRENCE ONLY)
#########
df <- join(x = df,
y = demVoters,
by = "ad",
type = "left",
match = "first")
# NOTE: the above is defacto random sampling of households, using
# home address as the household ID.  The randomization of all rows in
# demVoters is faster than actually using the sample() function.
# df = the household rep dataset (140,705)
# demVoters = the master dataset (156,955)
#########
# RELEVEL SEX IN DF SINCE THERE ARE NO U's
#########
df$Sex <- factor(df$Sex, levels = c("F", "M"))
#########
# RANDOMLY ASSIGN 60,000 *GENDERED* HOUSEHOLDS TO BE ROBOCALLED
#########
# CREATE VARIABLE (phase1) (initially populate with all FALSES)
df$phase1 <- FALSE
# ASSIGN 60,000 to be robocalled (only sample from those with known gender)
#2 steps
#1. create vector of indices to be taken
phase1Sample <- sample(x = 1:nrow(df[which(df$Sex != "U"),]),
size = 60000,
replace = FALSE)
#2. assign indices
df$phase1[which(df$Sex != "U")][phase1Sample] <- TRUE
#########
# LOGISTIC REGRESSION TO ENSURE BALANCING
#########
# First, create dummies as to whether or not they voted in 2010 and 2012
df$dum10 <- VoteFun("General10", data = df)
df$dum12 <- VoteFun("General12", data = df)
# for our model, we'll just use age, sex and voting in 2010 / 2012
# we don't have race, voter propensity
# and we choose not to use zip...
# Run model
fit <- glm(phase1 ~ Age + Sex + dum10 + dum12,
data = df,
family = binomial("logit"))
# View results
summary(fit)
# ! note: the having voted in 2012 general election dummy variable right on edge of p < 0.1 cutoff
# View confidence intervals on "odds" of assignment to phase 1
ci <- exp(cbind(OR = coef(fit), confint(fit, level = 0.9)))
ci
bp <- barplot(ci[-1,1], border = FALSE, plot=TRUE, ylim=c(0,1.2))
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
#########
# SAVE IMAGE FOR FAST LOADING LATER
#########
#save.image("temp3.RData")
# DOUBLE CHECK TO MAKE SURE PHASE 1 PEOPLE HAVE 60,000 UNIQUE
# ADDRESSES AND PHONE NUMBERS
length(df$ad[which(df$phase1)])
length(df$Phone[which(df$phase1)])
#########
# WRITE CSV OF THE 60,000 TO ROBOCALLED IN PHASE 1
#########
phase1 <- df[which(df$phase1),c("VANID", "State", "Phone")]
#write.csv(phase1, "preroboscreen/phase1.csv", row.names = FALSE)
#########
# END WRITING SINK
#########
txtStop()
# END HERE
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#########
length(df$ad[which(df$phase1)])
length(df$Phone[which(df$phase1)])
write.csv(phase1, "preroboscreen/phase1.csv", row.names = FALSE)
save.image("temp3.RData")
