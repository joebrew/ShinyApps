{
    "contents" : "library(shiny)\n\n#########################\n# SOURCE IN HELPER FUNCTION\n##############\n\n\n\n# Define server logic for slider examples\nshinyServer(function(input, output) {\n  \n  source(\"PowerFun.R\")\n  \n  mydata <- reactive({\n    PowerFun(total.n = as.numeric(input$total.n), \n             dv.variable.contact.rate = input$dv.variable.contact.rate,\n             percent.in.treatment = input$percent.in.treatment,\n             baseline.action.support.rate = input$baseline.action.support.rate,\n             treatment.application.rate = input$treatment.application.rate,\n             r.squared = input$r.squared,\n             power = input$power,\n             confidence.interval = input$confidence.interval,\n             #number.of.clusters = input$number.of.clusters,\n             #intra.cluster.correlation.coefficient = input$intra.cluster.correlation.coefficient,\n             checkbox = input$checkbox)     \n  })\n  \n  \n  \n  \n  \n  \n  # HIDDEN DETAILS\n  \n  output$Details <- renderText({ \n    if(input$checkbox){\n      print(\"Details\")\n    }\n  })\n  \n  \n  output$Number.of.outcome.measurements <- renderText({ \n    if(input$checkbox){\n      print(\"Number of outcome measurements:\")\n    }\n  })\n  \n  output$b5 <- renderText({ \n    if(input$checkbox){\n      print(mydata()$myValues[which(mydata()$myNames == \"b5\")])\n    }\n  })\n  \n  \n  \n  #############################\n  output$S.E. <- renderText({ \n    if(input$checkbox){\n      print(\"S.E.:\")\n    }\n  })\n  output$b14 <- renderText({ \n    if(input$checkbox){\n      \n      print(mydata()$myValues[which(mydata()$myNames == \"b14\")])\n    }\n  })\n  \n  #############################\n  output$ITT.MDE <- renderText({ \n    if(input$checkbox){\n      print(\"ITT MDE:\")\n    }\n  })\n  output$b16 <- renderText({ \n    if(input$checkbox){\n      \n      print(mydata()$myValues[which(mydata()$myNames == \"b16\")])\n    }\n  })\n  \n  \n  #############################\n  output$TOT.MDE <- renderText({ \n    if(input$checkbox){\n      print(\"ToT MDE:\")\n    }\n  })\n  output$b17 <- renderText({ \n    if(input$checkbox){\n      print(mydata()$myValues[which(mydata()$myNames == \"b17\")])\n    }\n  })\n  \n  ################### END OF DETAILS SECTION\n  \n  #b20\n  output$b20 <- renderText({\n    print(mydata()$myValues[which(mydata()$myNames == \"b20\")])\n  })\n  \n  #b22\n  output$b22 <- renderText({\n    print(mydata()$myValues[which(mydata()$myNames == \"b22\")])\n    \n  })\n  \n  #b23\n  output$b23 <- renderText({\n    print(mydata()$myValues[which(mydata()$myNames == \"b23\")])\n    \n  })\n  \n  #b25\n  output$b25 <- renderText({\n    print(mydata()$myValues[which(mydata()$myNames == \"b25\")])\n    \n  })\n  \n  #b26\n  output$b26 <- renderText({\n    print(mydata()$myValues[which(mydata()$myNames == \"b26\")])\n    \n  })\n  \n  \n  \n  \n  ############### BARPLOT\n  output$dplot <- renderPlot({ \n    \n    myCols <- adjustcolor(c( \"darkgreen\", \"grey\"), alpha.f=0.5)\n    \n    bp.elements <- c(mydata()$myValues[which(mydata()$myNames == \"b16\")],\n                     mydata()$myValues[which(mydata()$myNames == \"b17\")])\n    \n    #         bp.elements <- c(mydata()[\"b16\",],\n    #                          mydata()[\"b17\",])\n    bp.names <- c(\"ITT\",\n                  \"ToT\")\n    \n    mybp <- barplot(bp.elements*100,\n                    col=myCols,\n                    names.arg=bp.names,\n                    ylab=\"Minimum detectable effects (pp)\",\n                    main=NULL,\n                    border=FALSE)\n    \n    #legend(x=\"topright\", fill=c(\"yellow\", \"green\"), legend=bp.elements)\n    text(x=mybp[,1], y=bp.elements*100,\n         pos= ifelse(bp.elements >= 0.95*max(bp.elements, na.rm=TRUE),1,3),\n         labels=paste(round(bp.elements*100, digits=2), \"pp\"),\n         cex=1.5)\n    box(\"outer\")\n    \n  })\n  \n  \n  \n  \n  \n  \n  \n  \n  #   \n  #   #############################\n  #   output$b5 <- renderText({ \n  #     if(input$checkbox){\n  #       as.numeric(input$total.n) * as.numeric(input$dv.variable.contact.rate) / 100  \n  #     } \n  #   })\n  #   \n  #   #############################\n  #   output$b14 <- renderText({ \n  #     if(input$checkbox){\n  #       sqrt(\n  #         (\n  #           (\n  #             (\n  #               input$baseline.action.support.rate*\n  #                 (\n  #                   1-input$baseline.action.support.rate\n  #                 )\n  #             )*\n  #               (\n  #                 1-input$r.squared\n  #               )\n  #           )/\n  #             (\n  #               (\n  #                 input$percent.in.treatment*\n  #                   (\n  #                     1-input$percent.in.treatment\n  #                   )\n  #               )*\n  #                 (\n  #                   as.numeric(\n  #                     input$total.n\n  #                   ) * \n  #                     as.numeric(\n  #                       input$dv.variable.contact.rate\n  #                     ) / \n  #                     100\n  #                 ) \n  #             )\n  #         )\n  #       )\n  #     }\n  #   })\n  #   \n  #   #############################\n  #   output$b16 <- renderText({ \n  #     \n  #     if(input$checkbox){\n  #       (\n  #         qnorm(input$power/100) +\n  #           qnorm(((input$confidence.interval/100/2)+0.5))\n  #       )*\n  #         \n  #         \n  #         (sqrt(\n  #           (\n  #             (\n  #               (\n  #                 input$baseline.action.support.rate*\n  #                   (\n  #                     1-input$baseline.action.support.rate\n  #                   )\n  #               )*\n  #                 (\n  #                   1-input$r.squared\n  #                 )\n  #             )/\n  #               (\n  #                 (\n  #                   input$percent.in.treatment*\n  #                     (\n  #                       1-input$percent.in.treatment\n  #                     )\n  #                 )*\n  #                   (\n  #                     as.numeric(\n  #                       input$total.n\n  #                     ) * \n  #                       as.numeric(\n  #                         input$dv.variable.contact.rate\n  #                       ) / \n  #                       100\n  #                   ) \n  #               )\n  #           )\n  #         ))\n  #     }\n  #   })\n  #   \n  #   #############################\n  #   output$b17 <- renderText({ \n  #     if(input$checkbox){\n  #       \n  #       (\n  #         qnorm(input$power/100) +\n  #           qnorm(((input$confidence.interval/100/2)+0.5))\n  #       )*\n  #         \n  #         \n  #         (sqrt(\n  #           (\n  #             (\n  #               (\n  #                 input$baseline.action.support.rate*\n  #                   (\n  #                     1-input$baseline.action.support.rate\n  #                   )\n  #               )*\n  #                 (\n  #                   1-input$r.squared\n  #                 )\n  #             )/\n  #               (\n  #                 (\n  #                   input$percent.in.treatment*\n  #                     (\n  #                       1-input$percent.in.treatment\n  #                     )\n  #                 )*\n  #                   (\n  #                     as.numeric(\n  #                       input$total.n\n  #                     ) * \n  #                       as.numeric(\n  #                         input$dv.variable.contact.rate\n  #                       ) / \n  #                       100\n  #                   ) \n  #               )\n  #           )\n  #         ))/ \n  #         input$treatment.application.rate *100\n  #     }\n  #   })\n  #   \n  #   \n  #   # #############################\n  #   # output$b20 <- renderText({ \n  #   #   \n  #   #   if(input$checkbox){\n  #   #     if(input$number.of.clusters > 0){\n  #   #   as.numeric(input$total.n) / as.numeric(input$number.of.clusters)\n  #   #   }} else{NULL}\n  #   #   \n  #   # })\n  #   # \n  #   # #############################\n  #   # output$b22 <- renderText({ \n  #   #   if(input$checkbox){\n  #   #     if(input$number.of.clusters > 0){\n  #   #     \n  #   #   \n  #   #   sqrt((1+(( (as.numeric(input$total.n) / as.numeric(input$number.of.clusters))  -1)*\n  #   #              as.numeric(input$intra.cluster.correlation.coefficient))))}\n  #   #   }\n  #   #   \n  #   # })\n  #   # \n  #   # #############################\n  #   # output$b23 <- renderText({ \n  #   #   if(input$checkbox){\n  #   #     if(input$number.of.clusters > 0){\n  #   #     \n  #   #   \n  #   #   (  sqrt(\n  #   #     (\n  #   #       (\n  #   #         (\n  #   #           input$baseline.action.support.rate*\n  #   #             (\n  #   #               1-input$baseline.action.support.rate\n  #   #             )\n  #   #         )*\n  #   #           (\n  #   #             1-input$r.squared\n  #   #           )\n  #   #       )/\n  #   #         (\n  #   #           (\n  #   #             input$percent.in.treatment*\n  #   #               (\n  #   #                 1-input$percent.in.treatment\n  #   #               )\n  #   #           )*\n  #   #             (\n  #   #               as.numeric(\n  #   #                 input$total.n\n  #   #               ) * \n  #   #                 as.numeric(\n  #   #                   input$dv.variable.contact.rate\n  #   #                 ) / \n  #   #                 100\n  #   #             ) \n  #   #         )\n  #   #     )\n  #   #   ))*\n  #   #     (sqrt((1+(( (as.numeric(input$total.n) / as.numeric(input$number.of.clusters))  -1)*\n  #   #                 as.numeric(input$intra.cluster.correlation.coefficient)))))\n  #   #   }}\n  #   #   \n  #   # })\n  #   # \n  #   # #############################\n  #   # output$b25 <- renderText({ \n  #   #   if(input$number.of.clusters > 0){\n  #   #   \n  #   #   if(input$checkbox){\n  #   #     \n  #   #   \n  #   #   (\n  #   #     qnorm(input$power/100) +\n  #   #       qnorm(((input$confidence.interval/100/2)+0.5))\n  #   #   )*\n  #   #     (  sqrt(\n  #   #       (\n  #   #         (\n  #   #           (\n  #   #             input$baseline.action.support.rate*\n  #   #               (\n  #   #                 1-input$baseline.action.support.rate\n  #   #               )\n  #   #           )*\n  #   #             (\n  #   #               1-input$r.squared\n  #   #             )\n  #   #         )/\n  #   #           (\n  #   #             (\n  #   #               input$percent.in.treatment*\n  #   #                 (\n  #   #                   1-input$percent.in.treatment\n  #   #                 )\n  #   #             )*\n  #   #               (\n  #   #                 as.numeric(\n  #   #                   input$total.n\n  #   #                 ) * \n  #   #                   as.numeric(\n  #   #                     input$dv.variable.contact.rate\n  #   #                   ) / \n  #   #                   100\n  #   #               ) \n  #   #           )\n  #   #       )\n  #   #     ))*\n  #   #     (sqrt((1+(( (as.numeric(input$total.n) / as.numeric(input$number.of.clusters))  -1)*\n  #   #                 as.numeric(input$intra.cluster.correlation.coefficient)))))\n  #   #   }}\n  #   # })\n  #   # \n  #   # #############################\n  #   # output$b26 <- renderText({ \n  #   #   \n  #   #   \n  #   #   if(input$checkbox){\n  #   #     if(input$number.of.clusters > 0){\n  #   #     \n  #   #   \n  #   #   (  (\n  #   #     qnorm(input$power/100) +\n  #   #       qnorm(((input$confidence.interval/100/2)+0.5))\n  #   #   )*\n  #   #     (  sqrt(\n  #   #       (\n  #   #         (\n  #   #           (\n  #   #             input$baseline.action.support.rate*\n  #   #               (\n  #   #                 1-input$baseline.action.support.rate\n  #   #               )\n  #   #           )*\n  #   #             (\n  #   #               1-input$r.squared\n  #   #             )\n  #   #         )/\n  #   #           (\n  #   #             (\n  #   #               input$percent.in.treatment*\n  #   #                 (\n  #   #                   1-input$percent.in.treatment\n  #   #                 )\n  #   #             )*\n  #   #               (\n  #   #                 as.numeric(\n  #   #                   input$total.n\n  #   #                 ) * \n  #   #                   as.numeric(\n  #   #                     input$dv.variable.contact.rate\n  #   #                   ) / \n  #   #                   100\n  #   #               ) \n  #   #           )\n  #   #       )\n  #   #     ))*\n  #   #     (sqrt((1+(( (as.numeric(input$total.n) / as.numeric(input$number.of.clusters))  -1)*\n  #   #                 as.numeric(input$intra.cluster.correlation.coefficient)))))) / \n  #   #     input$treatment.application.rate\n  #   #   \n  #   #   }}\n  #   #   \n  #   # })\n  #   \n  #   #############################################\n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   #####################################################\n  #   \n  #   \n  #   #############################\n  #   output$zb5 <- renderText({ \n  #     \n  #     if(input$zcheckbox){\n  #       \n  #       as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100  \n  #       \n  #     }\n  #   })\n  #   \n  #   #############################\n  #   output$zb14 <- renderText({ \n  #     \n  #     if(input$zcheckbox){\n  #       \n  #       \n  #       #s.e.#########\n  #       sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #                (1-input$zr.squared))/\n  #               (( (input$zpercent.in.treatment/100)*\n  #                    (1- (input$zpercent.in.treatment/100) ))*\n  #                  (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100))))\n  #     }\n  #     ##############\n  #     \n  #     \n  #     \n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zb16 <- renderText({ \n  #     if(input$zcheckbox){\n  #       \n  #       \n  #       \n  #       (\n  #         qnorm(input$zpower/100) +\n  #           qnorm(((input$zconfidence.interval/100/2)+0.5))\n  #       )*\n  #         \n  #         #s.e.#########\n  #       sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #                (1-input$zr.squared))/\n  #               (( (input$zpercent.in.treatment/100)*\n  #                    (1- (input$zpercent.in.treatment/100) ))*\n  #                  (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100))))\n  #       ##############\n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zb17 <- renderText({ \n  #     \n  #     if(input$zcheckbox){\n  #       \n  #       \n  #       \n  #       ####################### zb16\n  #       ((qnorm(input$zpower/100) +\n  #           qnorm(((input$zconfidence.interval/100/2)+0.5))\n  #       )*\n  #         \n  #         sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #                  (1-input$zr.squared))/\n  #                 (( (input$zpercent.in.treatment/100)*\n  #                      (1- (input$zpercent.in.treatment/100) ))*\n  #                    (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100)))))/\n  #         \n  #         #######################\n  #       (input$ztreatment.application.rate/100)\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   \n  #   # #############################\n  #   # output$zb20 <- renderText({ \n  #   #   \n  #   #   if(input$zcheckbox){\n  #   #     if(input$znumber.of.clusters > 0){\n  #   #     \n  #   #   \n  #   #   as.numeric(input$ztotal.n) / as.numeric(input$znumber.of.clusters)\n  #   #   }}\n  #   #   \n  #   # })\n  #   # \n  #   # #############################\n  #   # output$zb22 <- renderText({ \n  #   #   if(input$zcheckbox){\n  #   #     if(input$znumber.of.clusters > 0){\n  #   #     \n  #   #   \n  #   #   sqrt((1+(( (as.numeric(input$ztotal.n) / as.numeric(input$znumber.of.clusters)) -1)*\n  #   #             (as.numeric(input$zintra.cluster.correlation.coefficient) ) )))\n  #   #   }}\n  #   #   \n  #   # })\n  #   # \n  #   # #############################\n  #   # output$zb23 <- renderText({ \n  #   #   \n  #   #   if(input$zcheckbox){\n  #   #     if(input$znumber.of.clusters > 0){\n  #   #     \n  #   # \n  #   #   \n  #   #   (\n  #   #     #s.e.#########\n  #   #     sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #   #              (1-input$zr.squared))/\n  #   #             (( (input$zpercent.in.treatment/100)*\n  #   #                  (1- (input$zpercent.in.treatment/100) ))*\n  #   #                (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100))))\n  #   #     ##############\n  #   #     ) * \n  #   #     (  sqrt((1+(( (as.numeric(input$ztotal.n) / as.numeric(input$znumber.of.clusters)) -1)*\n  #   #                   (as.numeric(input$zintra.cluster.correlation.coefficient) ) ))))\n  #   #   \n  #   #   }}\n  #   #  \n  #   # })\n  #   # \n  #   # #############################\n  #   # output$zb25 <- renderText({ \n  #   #   \n  #   #   if(input$zcheckbox){\n  #   #     if(input$znumber.of.clusters > 0){\n  #   #     \n  #   #   \n  #   #   \n  #   #   \n  #   #   (\n  #   #     qnorm(input$zpower/100) +\n  #   #       qnorm(((input$zconfidence.interval/100/2)+0.5))\n  #   #   )*\n  #   #     \n  #   #     # B 23#########\n  #   #   (\n  #   #     (\n  #   #       #s.e.#########\n  #   #       sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #   #                (1-input$zr.squared))/\n  #   #               (( (input$zpercent.in.treatment/100)*\n  #   #                    (1- (input$zpercent.in.treatment/100) ))*\n  #   #                  (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100))))\n  #   #       ##############\n  #   #     ) * \n  #   #       (  sqrt((1+(( (as.numeric(input$ztotal.n) / as.numeric(input$znumber.of.clusters)) -1)*\n  #   #                     (as.numeric(input$zintra.cluster.correlation.coefficient) ) ))))\n  #   #     )\n  #   #  \n  #   #   }}\n  #   # })\n  #   # \n  #   # #############################\n  #   # output$zb26 <- renderText({ \n  #   #   \n  #   #   if(input$zcheckbox){\n  #   #     if(input$znumber.of.clusters > 0){\n  #   #     \n  #   #   \n  #   #   (  (\n  #   #     qnorm(input$zpower/100) +\n  #   #       qnorm(((input$zconfidence.interval/100/2)+0.5))\n  #   #   )*\n  #   #     \n  #   #     # B 23#########\n  #   #   (\n  #   #     (\n  #   #       #s.e.#########\n  #   #       sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #   #                (1-input$zr.squared))/\n  #   #               (( (input$zpercent.in.treatment/100)*\n  #   #                    (1- (input$zpercent.in.treatment/100) ))*\n  #   #                  (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100))))\n  #   #       ##############\n  #   #     ) * \n  #   #       (  sqrt((1+(( (as.numeric(input$ztotal.n) / as.numeric(input$znumber.of.clusters)) -1)*\n  #   #                     (as.numeric(input$zintra.cluster.correlation.coefficient) ) ))))\n  #   #   )) /\n  #   #     (input$ztreatment.application.rate)*100  \n  #   #   \n  #   #   }}\n  #   # })\n  #   \n  #   \n  #   #############################\n  #   output$dplot <- renderPlot({ \n  #     \n  #     \n  #     \n  #     \n  #     itt.mde.d <- \n  #       (\n  #         qnorm(input$power/100) +\n  #           qnorm(((input$confidence.interval/100/2)+0.5))\n  #       )*\n  #       \n  #       \n  #       (sqrt(\n  #         (\n  #           (\n  #             (\n  #               input$baseline.action.support.rate*\n  #                 (\n  #                   1-input$baseline.action.support.rate\n  #                 )\n  #             )*\n  #               (\n  #                 1-input$r.squared\n  #               )\n  #           )/\n  #             (\n  #               (\n  #                 input$percent.in.treatment*\n  #                   (\n  #                     1-input$percent.in.treatment\n  #                   )\n  #               )*\n  #                 (\n  #                   as.numeric(\n  #                     input$total.n\n  #                   ) * \n  #                     as.numeric(\n  #                       input$dv.variable.contact.rate\n  #                     ) / \n  #                     100\n  #                 ) \n  #             )\n  #         )\n  #       ))\n  #     tot.mde.d <- \n  #       (\n  #         qnorm(input$power/100) +\n  #           qnorm(((input$confidence.interval/100/2)+0.5))\n  #       )*\n  #       \n  #       \n  #       (sqrt(\n  #         (\n  #           (\n  #             (\n  #               input$baseline.action.support.rate*\n  #                 (\n  #                   1-input$baseline.action.support.rate\n  #                 )\n  #             )*\n  #               (\n  #                 1-input$r.squared\n  #               )\n  #           )/\n  #             (\n  #               (\n  #                 input$percent.in.treatment*\n  #                   (\n  #                     1-input$percent.in.treatment\n  #                   )\n  #               )*\n  #                 (\n  #                   as.numeric(\n  #                     input$total.n\n  #                   ) * \n  #                     as.numeric(\n  #                       input$dv.variable.contact.rate\n  #                     ) / \n  #                     100\n  #                 ) \n  #             )\n  #         )\n  #       ))/ \n  #       input$treatment.application.rate *100\n  #     \n  #     adj.itt.mde.d <-  (\n  #       qnorm(input$power/100) +\n  #         qnorm(((input$confidence.interval/100/2)+0.5))\n  #     )*\n  #       (  sqrt(\n  #         (\n  #           (\n  #             (\n  #               input$baseline.action.support.rate*\n  #                 (\n  #                   1-input$baseline.action.support.rate\n  #                 )\n  #             )*\n  #               (\n  #                 1-input$r.squared\n  #               )\n  #           )/\n  #             (\n  #               (\n  #                 input$percent.in.treatment*\n  #                   (\n  #                     1-input$percent.in.treatment\n  #                   )\n  #               )*\n  #                 (\n  #                   as.numeric(\n  #                     input$total.n\n  #                   ) * \n  #                     as.numeric(\n  #                       input$dv.variable.contact.rate\n  #                     ) / \n  #                     100\n  #                 ) \n  #             )\n  #         )\n  #       ))*\n  #       (sqrt((1+(( (as.numeric(input$total.n) / as.numeric(input$number.of.clusters))  -1)*\n  #                   as.numeric(input$intra.cluster.correlation.coefficient)))))\n  #     \n  #     adj.tot.mde.d <-   (  (\n  #       qnorm(input$power/100) +\n  #         qnorm(((input$confidence.interval/100/2)+0.5))\n  #     )*\n  #       (  sqrt(\n  #         (\n  #           (\n  #             (\n  #               input$baseline.action.support.rate*\n  #                 (\n  #                   1-input$baseline.action.support.rate\n  #                 )\n  #             )*\n  #               (\n  #                 1-input$r.squared\n  #               )\n  #           )/\n  #             (\n  #               (\n  #                 input$percent.in.treatment*\n  #                   (\n  #                     1-input$percent.in.treatment\n  #                   )\n  #               )*\n  #                 (\n  #                   as.numeric(\n  #                     input$total.n\n  #                   ) * \n  #                     as.numeric(\n  #                       input$dv.variable.contact.rate\n  #                     ) / \n  #                     100\n  #                 ) \n  #             )\n  #         )\n  #       ))*\n  #       (sqrt((1+(( (as.numeric(input$total.n) / as.numeric(input$number.of.clusters))  -1)*\n  #                   as.numeric(input$intra.cluster.correlation.coefficient)))))) / \n  #       input$treatment.application.rate\n  #     \n  #     \n  #     \n  #     myCols <- adjustcolor(c( \"darkgreen\", \"grey\"), alpha.f=0.5)\n  #     \n  #     bp.elements <- c(itt.mde.d,\n  #                      tot.mde.d,\n  #                      adj.itt.mde.d,\n  #                      adj.tot.mde.d)\n  #     bp.names <- c(\"ITT\",\n  #                   \"ToT\",\n  #                   \"ADJ ITT\",\n  #                   \"ADJ ToT\")\n  #     \n  #     # if(input$number.of.clusters == 0){\n  #     bp.elements <- bp.elements[1:2]\n  #     bp.names <- bp.names[1:2]\n  #     # } else{\n  #     #   bp.elements <- bp.elements[3:4]\n  #     #   bp.names <- bp.names[3:4]\n  #     # }\n  #     \n  #     \n  #     \n  #     mybp <- barplot(bp.elements*100,\n  #                     col=myCols,\n  #                     names.arg=bp.names,\n  #                     ylab=\"Minimum detectable effects (pp)\",\n  #                     main=NULL,\n  #                     border=FALSE)\n  #     text(x=mybp[,1], y=bp.elements*100,\n  #          pos= ifelse(bp.elements >= 0.95*max(bp.elements, na.rm=TRUE),1,3),\n  #          labels=paste(round(bp.elements*100, digits=2), \"pp\"),\n  #          cex=1.5)\n  #     box(\"outer\")\n  #     \n  #     \n  #     \n  #     \n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$cplot <- renderPlot({ \n  #     \n  #     itt.mde.d <- \n  #       \n  #       (\n  #         qnorm(input$zpower/100) +\n  #           qnorm(((input$zconfidence.interval/100/2)+0.5))\n  #       )*\n  #       \n  #       #s.e.#########\n  #     sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #              (1-input$zr.squared))/\n  #             (( (input$zpercent.in.treatment/100)*\n  #                  (1- (input$zpercent.in.treatment/100) ))*\n  #                (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100))))\n  #     ##############\n  #     \n  #     tot.mde.d <- \n  #       ####################### zb16\n  #       ((qnorm(input$zpower/100) +\n  #           qnorm(((input$zconfidence.interval/100/2)+0.5))\n  #       )*\n  #         \n  #         sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #                  (1-input$zr.squared))/\n  #                 (( (input$zpercent.in.treatment/100)*\n  #                      (1- (input$zpercent.in.treatment/100) ))*\n  #                    (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100)))))/\n  #       \n  #       #######################\n  #     (input$ztreatment.application.rate/100)\n  #     \n  #     adj.itt.mde.d <- \n  #       \n  #       (\n  #         qnorm(input$zpower/100) +\n  #           qnorm(((input$zconfidence.interval/100/2)+0.5))\n  #       )*\n  #       \n  #       # B 23#########\n  #     (\n  #       (\n  #         #s.e.#########\n  #         sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #                  (1-input$zr.squared))/\n  #                 (( (input$zpercent.in.treatment/100)*\n  #                      (1- (input$zpercent.in.treatment/100) ))*\n  #                    (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100))))\n  #         ##############\n  #       ) * \n  #         (  sqrt((1+(( (as.numeric(input$ztotal.n) / as.numeric(input$znumber.of.clusters)) -1)*\n  #                       (as.numeric(input$zintra.cluster.correlation.coefficient) ) ))))\n  #     )\n  #     \n  #     adj.tot.mde.d <- \n  #       (  (\n  #         qnorm(input$zpower/100) +\n  #           qnorm(((input$zconfidence.interval/100/2)+0.5))\n  #       )*\n  #         \n  #         # B 23#########\n  #       (\n  #         (\n  #           #s.e.#########\n  #           sqrt(((( (input$zstandard.deviation.of.observations.across.units/100 )^2)*\n  #                    (1-input$zr.squared))/\n  #                   (( (input$zpercent.in.treatment/100)*\n  #                        (1- (input$zpercent.in.treatment/100) ))*\n  #                      (as.numeric(input$ztotal.n) * as.numeric(input$zdv.variable.contact.rate) / 100))))\n  #           ##############\n  #         ) * \n  #           (  sqrt((1+(( (as.numeric(input$ztotal.n) / as.numeric(input$znumber.of.clusters)) -1)*\n  #                         (as.numeric(input$zintra.cluster.correlation.coefficient) ) ))))\n  #       )) /\n  #       (input$ztreatment.application.rate)*100  \n  #     \n  #     \n  #     \n  #     myCols <- adjustcolor(c(\"darkgreen\", \"grey\"), alpha.f=0.5)\n  #     \n  #     bp.elements <- c(itt.mde.d,\n  #                      tot.mde.d,\n  #                      adj.itt.mde.d,\n  #                      adj.tot.mde.d)\n  #     bp.names <- c(\"ITT\",\n  #                   \"ToT\",\n  #                   \"ADJ ITT\",\n  #                   \"ADJ ToT\")\n  #     \n  #     #     if(input$znumber.of.clusters == 0){\n  #     bp.elements <- bp.elements[1:2]\n  #     bp.names <- bp.names[1:2]\n  #     #     } else{\n  #     #       bp.elements <- bp.elements[3:4]\n  #     #       bp.names <- bp.names[3:4]\n  #     #     }\n  #     \n  #     mybp <- barplot(bp.elements*100,\n  #                     col=myCols,\n  #                     names.arg=bp.names,\n  #                     ylab=\"Minimum detectable effects (pp)\",\n  #                     main=NULL, \n  #                     border=FALSE)\n  #     text(x=mybp[,1], y=bp.elements*100,\n  #          pos= ifelse(bp.elements >= .95*max(bp.elements, na.rm=TRUE),1,3),\n  #          labels=paste(round(bp.elements*100, digits=2), \"pp\"),\n  #          cex=1.5)\n  #     \n  #     box(\"outer\")\n  #     \n  #     \n  #     \n  #   })\n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   #################################\n  #   # DETAILS\n  #   #################################\n  #   \n  #   \n  #   \n  #   #############################\n  #   output$Details <- renderText({ \n  #     if(input$checkbox){\n  #       \n  #       \n  #       print(\"Details\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$Number.of.outcome.measurements <- renderText({ \n  #     if(input$checkbox){\n  #       \n  #       \n  #       print(\"Number of outcome measurements\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$S.E. <- renderText({ \n  #     if(input$checkbox){\n  #       \n  #       \n  #       print(\"S.E.:\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$ITT.MDE <- renderText({ \n  #     if(input$checkbox){\n  #       \n  #       \n  #       print(\"ITT MDE:\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$TOT.MDE <- renderText({ \n  #     if(input$checkbox){\n  #       \n  #       \n  #       print(\"ToT MDE:\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$Average.cluster.size <- renderText({ \n  #     if(input$checkbox){\n  #       if(input$number.of.clusters > 0){\n  #         \n  #         print(\"Average cluster size:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #       \n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$Square.root.of.variance.inflation.factor <- renderText({ \n  #     if(input$checkbox){\n  #       if(input$number.of.clusters > 0){\n  #         \n  #         print(\"Square root of variance inflation factor:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #       \n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$Adjusted.S.E. <- renderText({ \n  #     if(input$checkbox){\n  #       if(input$number.of.clusters > 0){\n  #         \n  #         print(\"Adjusted S.E.:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$Adj.ITT.MDE <- renderText({ \n  #     if(input$checkbox){\n  #       if(input$number.of.clusters > 0){\n  #         \n  #         print(\"Adjusted ITT MDE:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$Adj.TOT.MDE <- renderText({ \n  #     if(input$checkbox){\n  #       if(input$number.of.clusters > 0){\n  #         \n  #         print(\"Adjusted ToT MDE:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   \n  #   #################################\n  #   # Z DETAILS\n  #   #################################\n  #   \n  #   \n  #   \n  #   #############################\n  #   output$zDetails <- renderText({ \n  #     if(input$zcheckbox){\n  #       \n  #       \n  #       print(\"Details\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zNumber.of.outcome.measurements <- renderText({ \n  #     if(input$zcheckbox){\n  #       \n  #       \n  #       print(\"Number of outcome measurements\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zS.E. <- renderText({ \n  #     if(input$zcheckbox){\n  #       \n  #       \n  #       print(\"S.E.:\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zITT.MDE <- renderText({ \n  #     if(input$zcheckbox){\n  #       \n  #       \n  #       print(\"ITT MDE:\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zTOT.MDE <- renderText({ \n  #     if(input$zcheckbox){\n  #       \n  #       \n  #       print(\"ToT MDE:\")\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zAverage.cluster.size <- renderText({ \n  #     if(input$zcheckbox){\n  #       if(input$znumber.of.clusters > 0){\n  #         \n  #         print(\"Average cluster size:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #       \n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zSquare.root.of.variance.inflation.factor <- renderText({ \n  #     if(input$zcheckbox){\n  #       if(input$znumber.of.clusters > 0){\n  #         \n  #         print(\"Square root of variance inflation factor:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #       \n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zAdjusted.S.E. <- renderText({ \n  #     if(input$zcheckbox){\n  #       if(input$znumber.of.clusters > 0){\n  #         \n  #         print(\"Adjusted S.E.:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zAdj.ITT.MDE <- renderText({ \n  #     if(input$zcheckbox){\n  #       if(input$znumber.of.clusters > 0){\n  #         \n  #         print(\"Adjusted ITT MDE:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  #   #############################\n  #   output$zAdj.TOT.MDE <- renderText({ \n  #     if(input$zcheckbox){\n  #       if(input$znumber.of.clusters > 0){\n  #         \n  #         print(\"Adjusted ToT MDE:\")\n  #         \n  #         \n  #       } else {NULL}\n  #       \n  #     }\n  #     \n  #   })\n  #   \n  \n  \n  \n})",
    "created" : 1408555239296.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1294028511",
    "id" : "4128EAB",
    "lastKnownWriteTime" : 1408555335,
    "path" : "~/ShinyApps/powercalc/server.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}